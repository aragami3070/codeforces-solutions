// B. Подготовка к соревнованию
//
// Монокарп практикуется перед большим соревнованием.
// Он планирует решить n задач, чтобы убедиться, что он хорошо подготовлен.
// У каждой из этих задач есть уровень сложности: первая задача имеет уровень сложности 1,
// вторая задача имеет уровень сложности 2, и так далее до последней (n-й) задачи,
// которая имеет уровень сложности n.
//
// Монокарп выберет некоторый порядок, в котором он собирается решить все n задач.
// Каждый раз, когда он решает более сложную задачу, чем предыдущая решенная им, он радуется,
// так как ощущает свой прогресс. Монокарп никогда не радуется во время решения первой задачи в выбранном порядке.
//
// Например, если Монокарп решает задачи в порядке [3,(5),4,1,(6),2],
// он радуется дважды (соответствующие задачи взяты в круглые скобки).
//
// Монокарп хочет порадоваться ровно k раз во время своей тренировочной сессии.
// Помогите ему выбрать порядок, в котором он должен решать задачи!
//
// Входные данные
//
// Первая строка содержит одно целое число t (1≤t≤1000) — количество наборов входных данных.
//
// Каждый набор входных данных состоит из одной строки, содержащей два целых числа n и k (2≤n≤50 ; 0≤k≤n−1).
//
// Выходные данные
// Для каждого теста выведите n различных целых чисел от 1 до n, обозначающих порядок,
// в котором Монокарп должен решать задачи.
// Если существует несколько ответов, выведите любой из них.
//
// Можно показать, что при ограничениях задачи ответ всегда существует.
//
// Пример:
//
// Входные данные
// 3
// 6 2
// 5 4
// 5 0
// Выходные данные
// 3 5 4 1 6 2
// 1 2 3 4 5
// 5 4 3 2 1

use std::io;

fn main() {
    let mut input = String::new();

    io::stdin().read_line(&mut input).expect("Failed input");

    let t: u16 = input.trim().parse().expect("t will be a number (u16)");

    for _ in 0..t {
        input.clear();

        io::stdin().read_line(&mut input).expect("Failed input");

        let pair_input = input.split_once(' ').expect("Failed input");
        let n: u8 = pair_input.0.trim().parse().expect("n will be a number");
        let k: u8 = pair_input.1.trim().parse().expect("n will be a number");

        let not_happy_num = n - k;

        let mut result: Vec<u8> = (1..n + 1).into_iter().collect();

        if not_happy_num == n {
            result.reverse();
            for num in result {
                print!("{num} ")
            }
            continue;
        }

        for i in 0..not_happy_num {
            for j in 1..not_happy_num - i {
                result.swap((j - 1) as usize, j as usize);
            }
        }

        for num in result {
            print!("{num} ")
        }
    }
}
