// E2. Игра с шариками (сложная версия)
//
// Простая и сложная версии этой задачи отличаются друг от друга только ограничениями
// на количество наборов входных данных и n.
// В сложной версии количество наборов входных данных не превосходит 10^4,
// а сумма значений n по всем наборам входных данных не превосходит 2⋅10^5 .
// Кроме того, никаких дополнительных ограничений на значение n в одиночном наборе входных данных нет.
//
// Недавно Алисе и Бобу родители подарили шарики n различных цветов: получилось,
// что у Алисы a_1 шариков цвета 1, a_2 шариков цвета 2 ,..., a_n шариков цвета n.
// У Боба: b_1 шариков цвета 1, b_2 шариков цвета 2, ..., b_n шариков цвета n.
// Все a_i и b_i от 1 до 10^9.
//
// Посовещавшись, Алиса и Боб придумали следующую игру: игроки ходят по очереди, начиная с Алисы.
// На своём ходу игрок выбирает такой цвет i, что у обоих игроков есть хотя бы по одному шарику
// этого цвета.Он выбрасывает один шарик цвета i , а его противник — все шарики цвета i.
// Игра заканчивается, когда не существует такого цвета i, что у обоих игроков есть
// хотя бы по одному шарику этого цвета.
//
// Счёт в игре — это количество оставшихся шариков у Алисы минус количество оставшихся шариков
// у Боба по окончании игры. То есть счёт равен (A−B), где A — количество шариков у Алисы,
// а B — количество шариков у Боба в конце игры. Алиса хочет максимизировать счёт,
// а Боб — минимизировать.
//
// Посчитайте, какой счёт будет в конце игры, если оба игрока играют оптимально.
//
// Входные данные
//
// В первой строке задано одно целое число t (1≤t≤10^4) — количество наборов входных данных.
//
// Каждый набор входных данных состоит из трех строк:
// - в первой строке задано одно целое число n (2≤n≤2⋅10^5) — количество цветов шариков;
// - во второй строке заданы n целых чисел a_1,a_2,…,a_n (1≤a_i≤10^9), где a_i —
// количество шариков i-го цвета у Алисы;
// - в третьей строке заданы n целых чисел b_1,b_2,…,b_n (1≤b_i≤10^9), где bi —
// количество шариков i-го цвета у Боба;
//
// Дополнительное ограничение на входные данные: сумма n по всем наборам входных данных
// не превосходит 2⋅10^5.
//
// Выходные данные
//
// Для каждого набора входных данных выведите одно целое число — счёт в конце игры,
// если и Алиса и Боб будут действовать оптимально.
//
// Пример:
// Входные данные:
// 5
// 3
// 4 2 1
// 1 2 4
// 4
// 1 20 1 20
// 100 15 10 20
// 5
// 1000000000 1000000000 1000000000 1000000000 1000000000
// 1 1 1 1 1
// 3
// 5 6 5
// 2 1 7
// 6
// 3 2 4 2 5 5
// 9 4 7 9 2 5
//
// Выходные данные:
// 1
// -9
// 2999999997
// 8
// -6

use std::io;

fn main() {
    let mut input = String::new();

    io::stdin().read_line(&mut input).expect("Failed t input");

    let t: u16 = input.trim().parse().expect("t must be u16");

    for _ in 0..t {
        input.clear();
        io::stdin().read_line(&mut input).expect("Failed n input");
        let n: u32 = input.trim().parse().expect("n must be u32");

        input.clear();
        io::stdin().read_line(&mut input).expect("Failed a input");
        let alice_arr: Vec<u64> = input
            .split_whitespace()
            .map(|num| num.trim().parse::<u64>().expect("a array must be u64"))
            .collect();

        input.clear();
        io::stdin().read_line(&mut input).expect("Failed b input");
        let mut sum_arr: Vec<(usize, u64)> = Vec::new();
        let mut bob_arr: Vec<u64> = Vec::new();

        for (index, inp_str) in input.split_whitespace().enumerate() {
            let num: u64 = inp_str.trim().parse().expect("b array must be u64");
            bob_arr.push(num);
            sum_arr.push((index, num + &alice_arr[index]));
        }
        sum_arr.sort_by(|a, b| a.1.cmp(&b.1));

        let mut result: i64 = 0;
        let mut flag = true;

        for i in (0..n).rev() {
			let index = sum_arr[i as usize].0;
            match flag {
                true => {
                    result += (alice_arr[index as usize] - 1) as i64;
                    flag = false;
                }
                false => {
                    result -= (bob_arr[index as usize] - 1) as i64;
                    flag = true;
                }
            }
        }

        println!("{result}")
    }
}
