// B. Загаданное число
//
// Вадим загадал число x. Чтобы никто его не смог отгадать, он дописал к нему справа
// положительное количество нулей, тем самым получив новое число y. Но в целях перестраховки
// Вадим решил распространить число n=x+y. Найдите для данного n все подходящие x,
// которые Вадим мог загадать.
//
// Входные данные
//
// Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит
// одно целое число t (1≤t≤10^4) — количество наборов входных данных.
// Далее следуют описания наборов входных данных.
//
// В единственной строке каждого набора данных дано целое число n — распространённое
// Вадимом число (11≤n≤10^18)
//
// Выходные данные
//
// Для каждого числа n выведите 0, если подходящих x не существует. В противном случае
// выведите количество подходящих x, после чего выведите все подходящие x в порядке возрастания.
//
// Пример:
// Входные данные:
// 5
// 1111
// 12
// 55
// 999999999999999999
// 1000000000000000000
//
// Выходные данные:
// 2
// 11 101
// 0
// 1
// 5
// 3
// 999999999 999000999000999 90909090909090909
// 0

use std::io;

fn main() {
    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Failed input");

    let t: u16 = input.trim().parse().expect("t must be a u64");

    for _ in 0..t {
        input.clear();
        io::stdin().read_line(&mut input).expect("Failed input");
        let n: i128 = input.trim().parse().expect("n must be a u64");

        let mut tens: i128 = 10;
        let mut result: Vec<i128> = Vec::new();
        while (n / tens) > 0 {
            if n % (tens + 1) == 0 {
                result.push(n / (tens + 1));
            }
            tens *= 10;
        }

        result.sort();
        println!("{}", result.len());
        for nums in &result {
            print!("{nums} ")
        }

        if result.is_empty() {
            println!()
        }
    }
}
