// A. Редстоун?
// 
// Стив наткнулся на коллекцию из n шестерёнок, где i-я шестерёнка имеет a_i зубьев,
// и он хочет расположить их в ряд.
// 
// После того как он их расположит, Стив будет вращать самую левую шестерёнку 
// со скоростью 1 оборот в секунду. Для каждой последующей шестерёнки, пусть x —
// это количество зубьев, которое она имеет, y — это количество зубьев шестерёнки
// слева от неё, а z — это скорость, с которой вращается шестерёнка слева от неё.
// Тогда её скорость будет равна y/x⋅z оборотов в секунду.
// 
// Стив считает расположение приемлемым, если самая правая шестерёнка вращается
// со скоростью 1 оборот в секунду. Определите, может ли Стив приемлемо расположить
// шестерёнки в ряд.
// 
// Входные данные
// Каждый тест состоит из нескольких наборов входных данных. В первой строке находится
// одно целое число t (1≤t≤1000) — количество наборов входных данных. Далее следует
// описание наборов входных данных.
// 
// Первая строка каждого набора входных данных содержит одно целое число n (2≤n≤100) —
// количество шестерёнок, которое есть у Стива.
//
// Вторая строка каждого набора входных данных содержит n целых чисел a_1,a_2,…,a_n (2≤a_i≤100) —
// количество зубьев каждой шестерёнки.
// 
// Выходные данные
// 
// Для каждого набора входных данных выведите «YES», если Стив может расположить
// шестерёнки приемлемым образом, и «NO» в противном случае.
// 
// Вы можете выводить каждую букву в любом регистре (строчную или заглавную).
// Например, строки «yEs», «yes», «Yes» и «YES» будут приняты как положительный ответ.
// 
// Пример:
// Входные данные:
// 5
// 2
// 5 5
// 4
// 6 3 6 9
// 2
// 2 3
// 7
// 30 10 12 10 10 9 18
// 5
// 2 4 8 16 32
// 
// Выходные данные
// YES
// YES
// NO
// YES
// NO

use std::io;

fn main() {
    let mut input = String::new();

    io::stdin().read_line(&mut input).expect("Failed input");

    let t: u16 = input.trim().parse().expect("t should be a u16");

    for _ in 0..t {
        input.clear();
        io::stdin().read_line(&mut input).expect("Failed input");
        let _n: u8 = input.trim().parse().expect("n shoold be a u8");

        input.clear();
        io::stdin().read_line(&mut input).expect("Failed input");

        let mut flag = false;
		let mut index = (0, 0);
        for first_gear in input.split_whitespace() {
            for last_gear in input.split_whitespace() {
				let first = first_gear.trim().parse::<f64>().expect("Failed parse");
				let last = last_gear.trim().parse::<f64>().expect("Failed parse");
                if index.0 != index.1 && first / last == 1.0 {
                    flag = true;
                    break;
                }
				index.1 += 1;
            }
			if flag {
				break;
			}
			index.0 += 1;
			index.1 = 0;
        }

        if flag {
            println!("YES")
        } else {
            println!("NO")
        }
    }
}
