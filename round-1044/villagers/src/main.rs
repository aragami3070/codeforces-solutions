// B. Жители
// Стив живет в деревне с n другими жителями. К сожалению, из-за споров о распределении
// изумрудов ни один из этих жителей не является другом другого. Более того, у
// жителя i изначально есть недовольство g_i .
// 
// Стив может выполнять следующую операцию любое количество раз:
// - Выбрать двух жителей i и j и дать им max(g_i,g_j) изумрудов для совместного
// использования. В таком случае у них обоих недовольство уменьшается на min(g_i,g_j),
// и они становятся друзьями, если раньше не были.
// 
// Стив хочет сделать так, чтобы каждый житель стал другом каждому другому жителю 
// (возможно, через некоторые промежуточные дружбы); то есть от любого жителя можно
// проследовать по цепочке дружб, чтобы достичь любого другого жителя. Поскольку он не
// хочет слишком раздувать экономику деревни, вычислите минимальное количество 
// изумрудов, которое он должен раздать, чтобы достичь этой цели.
// 
// Входные данные
// 
// Каждый тест состоит из нескольких наборов входных данных. В первой строке находится
// одно целое число t (1≤t≤10^4) — количество наборов входных данных. Далее следует
// описание наборов входных данных.
// 
// Первая строка каждого набора входных данных содержит одно целое число n
// (2≤n≤2⋅10^5) — количество жителей.
// 
// Вторая строка каждого набора входных данных содержит n целых чисел g_1,g_2,…,g_n
// (1≤gi≤10^9) — начальное недовольство каждого жителя.
// 
// Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 2⋅10^5.
// 
// Выходные данные
// 
// Для каждого набора входных данных выведите одно целое число — минимальное
// количество изумрудов, которое Стив должен раздать, чтобы все стали друзьями.
// 
// Пример:
// Входные данные:
// 4
// 2
// 1 2
// 4
// 2 1 5 2
// 5
// 1000000000 1000000000 1000000000 1000000000 1000000000
// 6
// 3 1 4 1 5 9
//
// Выходные данные:
// 2
// 7
// 3000000000
// 14
// 

use std::io;
fn main() {
    let mut input = String::new();

    io::stdin().read_line(&mut input).expect("Failed input");

    let t: u16 = input.trim().parse().expect("t should be a u16");

    for _ in 0..t {
        input.clear();
        io::stdin().read_line(&mut input).expect("Failed input");
        let _n: u32 = input.trim().parse().expect("n shoold be a u32");

        input.clear();
        io::stdin().read_line(&mut input).expect("Failed input");

        let mut people: Vec<u64> = input
            .split_whitespace()
            .map(|num| num.trim().parse::<u64>().expect("Failed parse"))
            .collect();
        people.sort();

        let mut sum = 0;
        for i in (0..people.len()).rev().step_by(2) {
            sum += people[i];
        }
        println!("{sum}")
    }
}
